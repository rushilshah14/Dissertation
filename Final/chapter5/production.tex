\documentclass[../main.tex]{subfiles}


\begin{document}

\raggedright
The implementation process began with re-constructing the HTML template by Creative Tim\cite{creativeTimTemplate} to the different sections mentioned in chapter 4.2, JavaScript going along with the HTML and finally the Django back-end.

\subsection{HTML}
Redesigning the HTML code required changing the CSS, HTML components and removing unwanted JavaScript code. This brought about various bugs and unexpected changes in the overall HTML which crashed a few elements of the code such as Tables. With the use of Google Chrome and Console the debugging was completed and successful HTML pages were created for all three different sections as mentioned in Chapter 4.2. However, since pages are going to be repeated(Dashboard, Viewform, Profile, etc) only one HTML code was required and repeated depending on which panel you are logged in as. Table \ref{tab:htmlcom} shows what components were created into their relative files by redesigning the public licensed template. Each of these were combined with CSS and JavaScript from Chapter 4.2.2

\bgroup
\def\arraystretch{2}%  1 is the default, change whatever you need
\begin{table}[H]
\centering
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{ll}
\hline
\textbf{Page} & \textbf{HTML Components} \\ \hline
\multicolumn{1}{|l|}{Login} & \multicolumn{1}{l|}{POST Form(Email, Password)} \\ \hline
\multicolumn{1}{|l|}{Register} & \multicolumn{1}{l|}{POST Form(Firstname, Lastname, Email, Password1, Password2, DOB)} \\ \hline
\multicolumn{1}{|l|}{Password Change} & \multicolumn{1}{l|}{POST Form(Current Password, Password1, Password2)} \\ \hline
\multicolumn{1}{|l|}{Profile Page} & \multicolumn{1}{l|}{POST Form(Email;Disabled, Firstname, Lastname, DOB), TextArea(PublicData)} \\ \hline
\multicolumn{1}{|l|}{Dashboard} & \multicolumn{1}{l|}{Statistics, Table(ID, Description, Date, View)} \\ \hline
\multicolumn{1}{|l|}{View Form} & \multicolumn{1}{l|}{Text Fields(User Details, Circumstance), Table(Module Details), Table(Uploaded Files), POST Form(Files)} \\ \hline
\multicolumn{1}{|l|}{Units} & \multicolumn{1}{l|}{GET Form(Number of modules)} \\ \hline
\multicolumn{1}{|l|}{New Form} & \multicolumn{1}{l|}{POST Form(Circumstance, Module Details, Files)} \\ \hline
\multicolumn{1}{|l|}{Public Data} & \multicolumn{1}{l|}{TextArea(PublicData;Disabled)} \\ \hline
\end{tabular}%
}
\captionof{table}{HTML Components \&  Relative Pages}\label{tab:htmlcom} 
\end{table}
\egroup

\subsection{JavaScript}
After completion of the HTML design, it was important to add JavaScript in order to allow smooth control of the website. Along side the JavaScript received with the template by Creative Tim\cite{creativeTimTemplate} such as \textbf{Bootstrap}\cite{bootstrapfour} other scripts were manually added.  \\[4mm]

Tables would load numerous entries for the \textit{Secretary Panel} and the \textit{Scrutiny Panel}, this caused the page to be extensively long without the ability to filter out or search for a specific form, user or find pending forms. In order to achieve efficiency and sort out the entries in the table the use of \textbf{DataTables}\cite{datatables} came in handy. It automatically completed the following;
\begin{itemize}
  \item Added a search field - Allows the user to search for data in the entries
  \item Limited entries shown and added more pages - Allows efficiency and speed
  \item Sort by ascending or descending - Useful when searching for \textit{Pending} forms
\end{itemize}

The above are a requirement as being able to sort the forms, users and finding exactly something specific is an important factor which can be useful when a form needs to be reviewed or assessed. \\[4mm]

Another important public script used was \textbf{jsPDF}\cite{jsPDF}, as per the requirements, the secretary needs to be able to print and download the forms. PDF would be a perfect format to download these files as any browser, or PDF compatible viewer can be used to view the form. This JavaScript code converts the content inside a specific \textit{HTML container} and copies that data to a PDF which can then be downloaded by the user, in our case, the secretary. When the implementation of this was complete, the data from the form would be saved simply as text and would loose its colours and format. This would scramble up all the data and make it highly unreadable. To overcome this bug, \textbf{Html2Canvas} was used. \\[4mm]

\textbf{Html2Canvas}\cite{htmlcanvas} is a MIT licensed script which creates an image for everything on the current web page or a specific HTML container with the CSS (including colour and design). This is then copied onto the PDF created by jsPDF as mentioned above and made available for download. This allows the form to be printed exactly the same way it would be seen when viewing it on the web-page. \\[4mm]

Lastly, the secretary can also directly print the form while viewing it. All modern browsers have the ability to print directly what is being displayed on the current web page and with a simple line of code(\textit{window.print()}), a button on the view form html allows the browser to detect a print command being sent. 



\subsection{Django}
The main part of the implementation is combining both the \textbf{HTML} and \textbf{JavaScript} to work along with \textbf{Django} being the main controller. In the implementation, Django 2.2\cite{djangoLatest} which is the latest version was used. The first step was simply to combine the HTML, JavaScript, CSS and Django together into a folder system and define it on Django's settings. Within seconds the entire HTML was accessible on a Django running web server. The three sections below explain the process of coding in Django, the difficulties faces and lastly a small summary on back-end development. 

\subsubsection{Authentication \& Database}
After combining all the above, the authentication system was first to be built. As stated in Chapter 4.4, \textbf{All-Auth}\cite{allauth} was implemented into the Django system by importing the relevant packages. However, in order to avoid users creating multiple accounts with multiple emails, a manual \textbf{validation} was coded which only allows the student to register with their University Email Address (\textbf{sheffield.ac.uk}) only. All HTML files for All-Auth were overwritten by the HTML design already created in order to have a continuous site. At this point, all data being registered from All-Auth was bring stored into a \textbf{SQLite database} which was inbuilt with Django. Creating the database schema seen in \ref{fig:dbschema} was extremely simple with the \textbf{Model, View and Controller system} which Django follows. The database was ready in seconds after defining it in Models. \\[4mm]

\subsubsection{New Form}
At this point, the authentication system was ready as well as the database in which all the data would be stored. In order to retrieve data from the database there needed to be some data already inserted and so in order to do that the "Create new form" page had to be completed with back-end code. Different students may have different number of modules which are affected by their circumstance and so the first step would be to ask them to fill in how many modules are affected by their circumstance. This would send in a GET request with the parameter '\textbf{units}' and its \textbf{value} as an integer. The form for creating a new extenuating circumstance would then get this integer from the GET link and produce those many 'input fields' for the modules section of the form. The creation of a HTML POST form is made extremely easy with Django's \textbf{forms.py} system where you simply define the fields of a form such as text input or email and it will automatically present the form on the template where it is called. On successful submit, the student is notified, redirected to dashboard and the form data is saved into the database. The student is also notified if the form was not submitted fully and if it should be re-submitted.

\subsubsection{Dashboard} 
\textbf{Student:} Once the form has been submitted, the student can see it on the list of forms submitted. The dashboard provides statistics based on the current status of the all the forms submitted. These statistics are counted based on the status of each module under each form. If all modules are approved, the form will be '\textbf{entirely approved}' and this will be visible to the student under the statistics. The same goes for pending and rejected. However, if the modules are set to different statuses such as 'rejected' and 'approved' under one form, the overall result is '\textbf{partially approved}' or '\textbf{partially pending}' if the module has one or more pending modules. The student can see exactly which module has been rejected, approved or still pending.  All data is retrieved from the database as follows mathematical calculations where each module is added onto the statistics based on the other modules within the same form. The calculations as well as the display of each form was completed easily with the use of \textbf{FOR} loops.\\[4mm]

\textbf{Secretary \& Scrutiny Panel:} If the secretary or someone from the scrutiny panel logs into the system, the dashboard follows the same format as that of the students but with access to all forms submitted by students and their public data. The statistics of the forms are also similar to that of the students allowing the secretary or the scrutiny panel to know exactly how many pending forms are there which need to be updated. 

\subsubsection{View Form} 

\textbf{Student:} The dashboard links each of the forms created to a view form page. This page retrieves data from the database based on the GET parameters(form ID) received when requesting the page. Interlinked data from the database is then retrieved based on the \textbf{Form ID} such as the \textit{User} who created it, the \textit{Files} uploaded under the form and lastly the \textit{Modules} affected. Each of these is stored in different tables as they share a one to many relationship. Apart from simply displaying the form data already submitted, there is an option triggered by the secretary which creates a new \textbf{file up-loader} at the top of the page allowing the student to upload more files. The file up-loader submits the new files as a POST form and saves based on the form ID. \\[4mm]

\textbf{Secretary Panel:} This page follows the same format as the student view form with an exception of allowing the secretary have control over editing the final status and action for each module and requesting more files. Each module is displayed in a table with individual buttons bringing up a '\textbf{pop-up}' also known as '\textbf{Modal}' in HTML5. The modal pop-ups then allow the secretary to change values for the 'Action' and 'Status' of the form. \textbf{HTML drop-down} allows us to display text as the displayed options while the back-end gets a '\textbf{value}' which is stored into the database as an integer. This same value is automatically selected when displaying the current selection as it retrieves the integer from the database. A \textbf{switch-case toggle} was designed to allow the secretary to request more files from the student. When the switch is toggled, the database value for '\textbf{requestfiles}' is switched. This then displays the additional files up-loader as stated previously. The switch is called by a POST submit button with a '\textbf{name}' attribute to differentiate between the different POST forms. Lastly, for ease of access, a 'textarea' was created allowing direct change of the students public data without having to open multiple tabs and make changes. This again uses a POST form with a different 'name' attribute. Django '\textbf{views.py}' controls all the data received from the POST request and cleans the data ready to be saved into the database with the '\textbf{save()}' function. \\[4mm]

\textbf{Scrutiny Panel:} Since the scrutiny panel does not control the status directly on the portal, the view form page simply retrieves data from the database and displayed it with the use of HTML components such as p, a, h1, h2, h3, label, and many others. 

\subsubsection{Profile Page} 
The profile page simply displays the current users information. If the user is a student they can view their public data in a \textbf{disabled} '\textbf{textarea}', this allows scrolling of long paragraphs without having to extend the page size. Users cannot change their email address as this would bring about issues of multiple sign ups with different emails hence the \textbf{validation of only sheffield.ac.uk emails}. A simple POST form on the page retrieves the values current in the database and allows changing them after cleaning the new data. \textbf{This includes: firstname; lastname; dob only. }

\subsubsection{Student Record} 
Every user when registered is provided with a\textbf{ 8 digit random key} which can is used as a \textbf{GET parameter} to access their public record. Only users who have the \textbf{KEY} can access these records making it secure. This random key is stored in the database under '\textbf{User Profile}' and has a \textbf{unique schema} which makes sure that two users do not have the same KEY. The public data again is simply displayed with a '\textbf{textarea}' HTML component which is coded as mobile first. The purpose of using a random key is to \textbf{avoid pattern detection}(For example, using an email instead of a random key) and \textbf{unauthorised access.}  \\[4mm]

\textbf{Secretary Panel:} Since only the secretary can give out the direct link to access the student's record, they also have access to \textbf{regenerating the key}. This is a \textbf{safety feature} to avoid unauthorised access. The regeneration uses the same principle of using \textbf{Python's Random package} to generate an \textbf{8 digit key} and replace it in the database. 

\subsubsection{Email Notifications} 
Email notification were created with the use of \textbf{Gmail's SMTP services}. Django has an inbuilt system which makes mailing and bulk mailing extremely easy. The SMTP details of the sender email can be set in the settings.py page which directly links to the \textbf{Django mailer} and with a simple \textit{sendMail} function we can send mail. To make debugging and later changes to the email text being sent, each message is stored as a TXT file which is called in the \textit{sendMail} function when required. For example, when a new user registers, a confirmation email is sent to the user using the \textit{sendMail} function and uses the data from \textbf{NewUser.txt} as the main message. Email notifications have been implemented for the following instances;

\begin{itemize}
  \item New user registration
  \item Password reset and confirmation of password change
  \item Successful creation of extenuating circumstance form
  	\begin{itemize}
     \item Email is sent to both Student and Secretary
    \end{itemize}
  \item Updated status of the form (Rejected/Approved)
  \item Requested additional files
  	\begin{itemize}
     \item Email is sent to the Student and once uploaded to the Secretary
    	\end{itemize} 
\end{itemize}

\end{document}
